#+title: Emacs from Scratch (EFS) personal config
#+author: Rafael Ito
#+description: Emacs from Scratch (EFS) personal config
#+startup: showeverything
#+options: toc:2
#+property: header-args:emacs-lisp :tangle ./init.el
#+auto_tangle: t

* Table of Contents :toc_1:
- [[#ui][UI]]
- [[#miscellaneous][Miscellaneous]]
- [[#package-manager][Package Manager]]
- [[#evil][Evil]]
- [[#theme][Theme]]
- [[#modeline][Modeline]]
- [[#org][Org]]
- [[#dired][Dired]]
- [[#general][General]]
- [[#orderless][orderless]]
- [[#ivy][Ivy]]
- [[#rainbow-delimiters][rainbow-delimiters]]
- [[#helpful][helpful]]
- [[#which-key][which-key]]
- [[#hydra][Hydra]]
- [[#projectile][Projectile]]
- [[#magit][Magit]]
- [[#undo-tree][undo-tree]]
- [[#dashboard][Dashboard]]
- [[#docker][Docker]]
- [[#windmove][windmove]]
- [[#ansible][Ansible]]
- [[#keycast][Keycast]]
- [[#zoom-window][zoom-window]]
- [[#persistent-scratch][persistent-scratch]]
- [[#systemd][systemd]]
- [[#consult-gh][consult-gh]]
- [[#dimmer][dimmer]]
- [[#wgrep][wgrep]]

* UI :noexport_1:
** Misc
#+begin_src emacs-lisp
(setq inhibit-startup-message t)                  ;; disable startup massage
(setq visible-bell t)                             ;; disable beep and set visible bell
#+end_src
** Bars
#+begin_src emacs-lisp
(menu-bar-mode -1)                                ;; disable menu bar
(tool-bar-mode -1)                                ;; disable toolbar
(scroll-bar-mode -1)                              ;; disable scrollbar
#+end_src
** Line number
*** Settings
#+begin_src emacs-lisp
(global-display-line-numbers-mode t)              ;; enable line number
(setq display-line-numbers-type 'visual)          ;; set line number to relative (visually)
(column-number-mode)                              ;; enable column number
#+end_src
*** Exceptions
Disable line numbers for some modes.
#+begin_src emacs-lisp
;; function to disable line numbers
(defun efs/disable-line-numbers ()
  (display-line-numbers-mode -1))

;; disable line numbers in these modes
(dolist
  (mode '(
    dashboard-mode-hook
    ;;org-mode-hook
    ;;term-mode-hook
    ;;shell-mode-hook
    ;;treemacs-mode-hook
    ;;eshell-mode-hook
  ))
  (add-hook mode #'efs/disable-line-numbers)
)
#+end_src
** Transparency
#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(alpha-background . 97))
** Gaps
#+begin_src emacs-lisp
(use-package frame
  :ensure nil  ;; do not install (Dired is already built-in)
  :after doom-themes
  :custom
  ;;(window-divider-default-places t)          ;; set dividers in both bottom and right
  (window-divider-default-places 'right-only)  ;; set dividers for vertical splits only
  (window-divider-default-bottom-width 0)      ;; bottom gaps width (in pixels)
  (window-divider-default-right-width 15)      ;; right gaps width (in pixels)
#+end_src
*** Vertical
#+begin_src emacs-lisp
  ;;:custom-face
  ;;(window-divider ((t (:foreground "#282c34"))))  ;; internal gaps (between windows)
  ;;(internal-border ((t (:background "#282c34")))) ;; external gaps (padding around the frame)
  :config
  ;; set gaps around the frame
  (add-to-list 'default-frame-alist '(internal-border-width . 0))
  (let ((bg-color (face-attribute 'default :background)))
    ;; set the internal/external divider
    (set-face-attribute 'window-divider nil :foreground bg-color)   ;; foreground creates the line
    (set-face-attribute 'internal-border nil :background bg-color)) ;; background creates the padding
#+end_src
*** Horizontal
#+begin_src emacs-lisp
  ;; function to apply the "opaque text" trick
  (defun efs/apply-opaque-header-line (&rest _args)
    "Make the header-line look like a solid, opaque divider."
    (let ((divider-color (face-attribute 'window-divider :foreground nil t)))
      ;; fallback if color is not found
      (when (or (not divider-color) (eq divider-color 'unspecified))
        (setq divider-color (face-attribute 'default :background)))
      ;; apply the color to the foreground (text), instead of background
      (set-face-attribute 'header-line nil
                          :foreground divider-color  ;; color of the block chars
                          :background nil            ;; transparent background (ignored)
                          :height 0.75               ;; adjust the "width" of the gap
                          :box nil
                          :inherit nil)
      ;; ensure vertical divider matches
      (set-face-attribute 'window-divider nil :foreground divider-color)))
  ;;---------------------------
  ;; reload immediately and after loading themes
  (efs/apply-opaque-header-line)
  (advice-add 'load-theme :after #'efs/apply-opaque-header-line)
  ;;---------------------------
  ;; "opaque text" trick: use a "full block" character repeated across the width
  ;; this creates a solid bar made of "text", which remains opaque
  (setq-default header-line-format '((:eval (make-string (ceiling (* (window-total-width) 2)) ?\u2588))))
#+end_src
*** Hide top header-line
#+begin_src emacs-lisp
;; hide header line if window is at the top
  (setq-default header-line-format
    '((:eval
       (if (window-at-side-p nil 'top)
         nil  ;; if at top --> no header line (frame border handles the gap)
         (make-string (ceiling (* (window-total-width) 2)) ?\u2588))))) ;; if not, show gap
#+end_src
*** EoS :noexport:
#+begin_src emacs-lisp
  :init
  (window-divider-mode 1)
)
#+end_src
** Fonts
*** Installation
#+begin_src sh
sudo pacman -S ttf-jetbrains-mono ttf-ubuntu-font-family
#+end_src
*** Setting faces
Source: https://systemcrafters.net/emacs-tips/using-the-emacs-daemon/#configuring-the-ui-for-new-frames
#+begin_src emacs-lisp
(defun efs/set-font-faces ()
  (message "Setting faces!")

  ;; Default
  (set-face-attribute 'default nil
    :font "JetBrains Mono"
    :height 120
    :weight 'medium)

  ;; Variable pitch
  (set-face-attribute 'variable-pitch nil
    :font "Ubuntu"
    :height 130
    :weight 'medium)

  ;; Fixed pitch
  (set-face-attribute 'fixed-pitch nil
    :font "JetBrains Mono"
    :height 120
    :weight 'medium)
)
#+end_src
*** Call after daemon
#+begin_src emacs-lisp
(if (daemonp)
  (add-hook 'after-make-frame-functions
            (lambda (frame)
              ;;(setq doom-modeline-icon t)
              (with-selected-frame frame
                (efs/set-font-faces))))
  (efs/set-font-faces))
#+end_src
#+begin_src emacs-lisp
#+end_src
#+end_src
** Zoom in/out
*** Keyboard
#+begin_src emacs-lisp
(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
#+end_src
*** Mouse
#+begin_src emacs-lisp
(global-set-key (kbd "<C-wheel-up>") 'text-scale-increase)
(global-set-key (kbd "<C-wheel-down>") 'text-scale-decrease)
#+end_src
* Miscellaneous :noexport_1:
** Copy/Paste for Wayland
*** Copy
#+begin_src emacs-lisp
;; send text to wl-copy via stdin with strict UTF-8 encoding
(setq interprogram-cut-function
  (lambda (text &optional push)
    (let ((process-connection-type nil))
      (let ((proc (start-process "wl-copy" nil "wl-copy" "--type" "text/plain;charset=utf-8")))
      ;; set UTF-8 for pipe (instead of Latin-1)
      (set-process-coding-system proc 'utf-8 'utf-8)
      ;; send the text to the process's standard input
      (process-send-string proc text)
      ;; signal EOF to wl-copy
      (process-send-eof proc)))))
#+end_src
*** Paste
#+begin_src emacs-lisp
;; read from wl-paste, but verify it's new content
(setq interprogram-paste-function
      (lambda ()
        (let ((clipboard-text (shell-command-to-string "wl-paste -n | tr -d '\r'")))
          ;; check if the clipboard text is different from what Emacs already has
          ;; if they are the same, return nil so Emacs uses its internal "smart" yank (keeping lines/blocks).
          (unless (string= clipboard-text (or (car kill-ring) ""))
            clipboard-text))))
#+end_src
** Cut/Copy/Paste
#+begin_src emacs-lisp
(global-set-key (kbd "<M-f17>") 'execute-extended-command)  ;; M-x
(global-set-key (kbd "<S-f17>") 'evil-yank)                 ;; copy
(global-set-key (kbd "<C-f17>") 'evil-paste-after)          ;; paste
#+end_src
** ESC
Make ESC quit prompts.
#+begin_src emacs-lisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+end_src
** Save Place
When you visit a file, point goes to the last place where it was when you previously visited the same file.
#+begin_src emacs-lisp
(save-place-mode 1)
#+end_src
** Window navigation
#+begin_src emacs-lisp
(global-set-key (kbd "s-<left>")  'evil-window-left)
(global-set-key (kbd "s-<down>")  'evil-window-down)
(global-set-key (kbd "s-<up>")    'evil-window-up)
(global-set-key (kbd "s-<right>") 'evil-window-right)
(global-set-key (kbd "C-c n") 'evil-window-left)
(global-set-key (kbd "C-c e") 'evil-window-down)
(global-set-key (kbd "C-c i") 'evil-window-up)
(global-set-key (kbd "C-c o") 'evil-window-right)
#+end_src
** Debug
#+begin_src emacs-lisp
(setq debug-on-error t)
#+end_src
** Auto-Revert
#+begin_src emacs-lisp
(global-auto-revert-mode t)
#+end_src
** y or n
#+begin_src emacs-lisp
(setq use-short-answers t)
#+end_src
** Highlight current line
#+begin_src emacs-lisp
(global-hl-line-mode 1)
#+end_src
** kill window
#+begin_src emacs-lisp
(global-set-key (kbd "M-s-q") 'evil-quit)
(global-set-key (kbd "M-s-w") 'kill-current-buffer)
#+end_src
** Autotiling
https://emacs.stackexchange.com/a/21652
#+begin_src emacs-lisp
(defun split-window-autotiling ()
  (interactive)
  (if (> (window-pixel-width) (window-pixel-height))
    (split-window-horizontally)
    (split-window-vertically)))
#+end_src
*** Keybinding
#+begin_src emacs-lisp
(global-set-key (kbd "M-s-g") '(lambda () (interactive) (split-window-autotiling) (other-window 1) (counsel-find-file)))
#+end_src
** ﹡scratch﹡ buffer
Prevent scratch buffer from being killed.
#+begin_src emacs-lisp
(add-hook 'kill-buffer-query-functions #'kill/dont-kill-scratch)
(defun kill/dont-kill-scratch ()
  (if (not (equal (buffer-name) "*scratch*")) t
    (message "Not allowed to kill %s, burying instead" (buffer-name))
    (bury-buffer)
    nil))
#+end_src
** Read-only
Disable read-only for some modes.
#+begin_src emacs-lisp
(dolist (mode '(dashboard-mode-hook))
  (add-hook mode (lambda () (read-only-mode -1))))
#+end_src
** Focus follows mouse
#+begin_src emacs-lisp
(setq focus-follows-mouse t)
(setq mouse-autoselect-window t)
(setq mouse-wheel-follow-mouse nil)  ;; mouse scroll acts on focused window

;; function to warp mouse cursor to the center of the window
(defun efs/warp-mouse-to-center (&rest _)
  "Move mouse to the center of the current window."
  (when (display-graphic-p)
    (let* ((edges (window-pixel-edges))
           (left   (nth 0 edges))
           (top    (nth 1 edges))
           (right  (nth 2 edges))
           (bottom (nth 3 edges))
           (x      (+ left (/ (- right left) 2)))
           (y      (+ top (/ (- bottom top) 2))))
      ;;(message "Moving mouse cursor to x=%s y=%s" x y)
      ;; move mouse cursor with ydotool
      (start-process-shell-command
        (format "Moving-mouse-to-x=%d-y=%d" x y)
        "*Messages*"
        (format "ydotool mousemove -x -9999 -y -9999 && ydotool mousemove -x %s -y %s" (/ x 2) (/ y 2)))
      ;; the next command only works on X11
      ;;(set-mouse-pixel-position (selected-frame) x y))))
    )
  )
)

;; set advice for evil-window commands
(dolist (cmd '(evil-window-left
               evil-window-right
               evil-window-up
               evil-window-down
               evil-window-next
               evil-window-prev))
  (advice-add cmd :after #'efs/warp-mouse-to-center))
#+end_src
* Package Manager :noexport_1:
Git repo: [[https://github.com/progfolio/elpaca][Elpaca]]
#+ATTR_ORG: :width 75
[[./icon/elpaca.svg]]
** Installation
#+begin_src emacs-lisp
(defvar elpaca-installer-version 0.8)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil :depth 1
                              :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (< emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                  ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                  ,@(when-let* ((depth (plist-get order :depth)))
                                                      (list (format "--depth=%d" depth) "--no-single-branch"))
                                                  ,(plist-get order :repo) ,repo))))
                  ((zerop (call-process "git" nil buffer t "checkout"
                                        (or (plist-get order :ref) "--"))))
                  (emacs (concat invocation-directory invocation-name))
                  ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                        "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                  ((require 'elpaca))
                  ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (load "./elpaca-autoloads")))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
#+end_src
** use-package integration
#+begin_src emacs-lisp
(elpaca elpaca-use-package
  ;; Enable Elpaca support for use-package's :ensure keyword.
  (elpaca-use-package-mode))
#+end_src
** Setup
#+begin_src emacs-lisp
(setq use-package-always-ensure t)                ;; set ":ensure t" for every package
#+end_src
* Evil
** evil
#+begin_src emacs-lisp
(use-package evil
  :init
  (setq evil-want-integration t)      ;; enable evil-integration
  (setq evil-want-keybinding nil)     ;; disable evil-keybindings (use )
  (setq evil-want-C-u-scroll t)       ;; disable =universal-argument= to use C-u to scroll up
  (setq evil-want-C-i-jump nil)       ;; disable C-i to jump forward in the list
  (setq evil-want-Y-yank-to-eol t)    ;; set Y to y$ (yank to the end of the line)
  (setq evil-want-minibuffer t)       ;; enable evil in minibuffer
  :custom
  (setq evil-undo-system 'undo-tree)  ;; set undo system to =undo-tree=
  :config
  ; F13
  (evil-define-key nil evil-insert-state-map
    ; dead_acute lowercase
    (kbd "<f13> a") (lambda () (interactive) (insert "á"))
    (kbd "<f13> e") (lambda () (interactive) (insert "é"))
    (kbd "<f13> i") (lambda () (interactive) (insert "í"))
    (kbd "<f13> o") (lambda () (interactive) (insert "ó"))
    (kbd "<f13> u") (lambda () (interactive) (insert "ú"))
    (kbd "<f13> c") (lambda () (interactive) (insert "ç"))
    (kbd "<f13> SPC") (lambda () (interactive) (insert "'"))
    (kbd "<f13> <f13>") (lambda () (interactive) (insert "´"))
    ; dead_acute uppercase
    (kbd "<f13> A") (lambda () (interactive) (insert "Á"))
    (kbd "<f13> E") (lambda () (interactive) (insert "É"))
    (kbd "<f13> I") (lambda () (interactive) (insert "Í"))
    (kbd "<f13> O") (lambda () (interactive) (insert "Ó"))
    (kbd "<f13> U") (lambda () (interactive) (insert "Ú"))
    (kbd "<f13> C") (lambda () (interactive) (insert "Ç"))
    ; misc lowercase
    (kbd "<f13> n") (lambda () (interactive) (insert "'n "))
    (kbd "<f13> m") (lambda () (interactive) (insert "'m "))
    (kbd "<f13> r") (lambda () (interactive) (insert "'r "))
    (kbd "<f13> s") (lambda () (interactive) (insert "'s "))
    (kbd "<f13> t") (lambda () (interactive) (insert "'t "))
    ; misc upperrcase
    (kbd "<f13> N") (lambda () (interactive) (insert "'N "))
    (kbd "<f13> M") (lambda () (interactive) (insert "'M "))
    (kbd "<f13> R") (lambda () (interactive) (insert "'R "))
    (kbd "<f13> S") (lambda () (interactive) (insert "'S "))
    (kbd "<f13> T") (lambda () (interactive) (insert "'T ")))

  ; Shift-F13
  (evil-define-key nil evil-insert-state-map
    ; double quotes
    (kbd "S-<f13> SPC") (lambda () (interactive) (insert "\""))
    (kbd "S-<f13> <f13>") (lambda () (interactive) (insert "\""))
    ; tilde lowercase
    (kbd "S-<f13> a") (lambda () (interactive) (insert "ã"))
    (kbd "S-<f13> o") (lambda () (interactive) (insert "õ"))
    (kbd "S-<f13> n") (lambda () (interactive) (insert "ñ"))
    ; tilde uppercase
    (kbd "S-<f13> A") (lambda () (interactive) (insert "Ã"))
    (kbd "S-<f13> O") (lambda () (interactive) (insert "Õ"))
    (kbd "S-<f13> N") (lambda () (interactive) (insert "Ñ"))
    ; tilde miscellaneous
    (kbd "S-<f13> S-<f13>") (lambda () (interactive) (insert "~"))
    (kbd "S-<f13> /") (lambda () (interactive) (insert "~/"))
    (kbd "S-<f13> .") (lambda () (interactive) (insert "~/."))
    ; tilde paths
    (kbd "S-<f13> g") (lambda () (interactive) (insert "~/git/"))
    (kbd "S-<f13> k") (lambda () (interactive) (insert "~/git/keebab"))
    (kbd "S-<f13> d") (lambda () (interactive) (insert "~/dotfiles/"))
    (kbd "S-<f13> c") (lambda () (interactive) (insert "~/.config/"))
    (kbd "S-<f13> s") (lambda () (interactive) (insert "~/.config/scripts/"))
    (kbd "S-<f13> v") (lambda () (interactive) (insert "~/.config/nvim/"))
    (kbd "S-<f13> x") (lambda () (interactive) (insert "~/.config/xremap/"))
    (kbd "S-<f13> w") (lambda () (interactive) (insert "~/.config/waybar/"))
    (kbd "S-<f13> z") (lambda () (interactive) (insert "~/.config/zsh/")))

  ;; minibuffer
  (evil-define-key 'insert minibuffer-local-map
    (kbd "<escape>") 'keyboard-escape-quit
    (kbd "C-e")        'ivy-next-line      ;; down
    (kbd "C-i")        'ivy-previous-line  ;; up
    (kbd "C-o")        'ivy-alt-done       ;; confirm
    (kbd "C-<tab>")    'ivy-alt-done       ;; confirm
    (kbd "C-<return>") 'ivy-alt-done)      ;; confirm

  ; preserve clipboard while pasting
  (defun paste-clipboard-preserve ()
    (interactive)
    (when (use-region-p)
      (delete-region (region-beginning) (region-end)))
    (yank))
  ; only work in visual mode
  (global-set-key (kbd "C-S-v") #'paste-over-selection)
  (define-key evil-visual-state-map (kbd "C-p") #'paste-clipboard-preserve)
  
  ;; miscellaneous
  (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)  ;; ensure normal mode on C-g (keyboard-quit)
  (evil-mode 1))
** evil-collections
https://github.com/emacs-evil/evil-collection
#+begin_src emacs-lisp
(use-package evil-collection
  :after evil
  :config
  ;; Colemak-DH layout remap
  ;; source: https://github.com/emacs-evil/evil-collection/pull/724
  (defvar evil-colemak-dh-translations
    '("n" "h"  "N" "H"
      "e" "j"  "E" "J"
      "i" "k"  "I" "K"
      "o" "l"  "O" "L"
      "h" "o"  "H" "O"
      "s" "i"  "S" "I"
      "l" "e"  "L" "E"
      "k" "n"  "K" "N"

      "gn" "gh"  "gN" "gH"
      "ge" "gj"  "gE" "gJ"
      "gi" "gk"  "gI" "gK"
      "go" "gl"  "gO" "gL"
      "gh" "go"  "gH" "gO"
      "gs" "gi"  "gS" "gI"
      "gl" "ge"  "gL" "gE"
      "gk" "gn"  "gK" "gN")
  "Evil keys to translate for the Colemak-DH keyboard layout.")

  ;; install a hook to translate bindings from evil-collection.
  (defun evil-colemak-dh-translate-keys (mode keymaps &optional states &rest _rest)
    "Translate bindings for MODE in KEYMAPS for the Colemak-DH layout in STATES."
    (apply #'evil-collection-translate-key
           (or states '(normal motion visual))
           keymaps
           evil-colemak-dh-translations))

  ;; guard logic: use a variable to ensure the colemak translations runs once.
  (defvar efs/evil-collection-initialized nil)

  ;; translate the main evil-mode bindings, if not done yet.
  (unless efs/evil-collection-initialized
    (apply #'evil-collection-translate-key
      nil
      '(evil-normal-state-map
        evil-motion-state-map
        evil-operator-state-map
        evil-visual-state-map
        evil-window-map)
      evil-colemak-dh-translations)
    ;; add translation to hook
    (add-hook 'evil-collection-setup-hook #'evil-colemak-dh-translate-keys)
    ;; delete certain modes from evil-collection
    ;; delete "gnus" (bugfix: conflict with colemak remaps when reloading Emacs config)
    ;;(delete 'gnus evil-collection-mode-list)
    ;; enable evil-collection bindings in all modes (except the deleted ones above)
    (evil-collection-init)
    ;; mark as done so reloads don't scramble the keys
    (setq efs/evil-collection-initialized t)
  )
)
#+end_src
** evil-colemak
Original repo: https://github.com/wbolster/emacs-evil-colemak-basics
Forked repo: https://github.com/ito-rafael/evil-colemak
#+begin_src emacs-lisp :tangle no
(use-package evil-colemak
  :ensure (evil-colemak.el :host github :repo "ito-rafael/evil-colemak")
  :after evil-collection
  :config
  (global-evil-colemak-mode))
#+end_src
* Theme
** doom-themes
https://github.com/doomemacs/themes
#+begin_src emacs-lisp
(use-package doom-themes
  :config
  (custom-set-faces
    '(line-number ((t (:foreground "dim gray")))))           ;; set line numbers color to gray
    '(line-number-current-line ((t (:foreground "white"))))  ;; set current line number color to white
  ;;---------------------------
  ;; function to update gaps color
  (defun efs/sync-window-borders (&optional frame)
    "Update window divider colors to match the theme."
    ;; if called interactively or without args, ensure we target the current frame
    (let* ((frame (or frame (selected-frame)))
           ;; look up the color specifically for this frame
           (bg-color (face-attribute 'default :background frame t)))
      (set-face-attribute 'header-line nil
                          :background bg-color
                          :foreground bg-color)
      (set-face-attribute 'window-divider frame :foreground bg-color)
      (set-face-attribute 'internal-border frame :background bg-color)))

  ;; reload gaps colors
  (efs/sync-window-borders)
  ;; reload gaps colors automatically whenever theme is loaded
  (add-hook 'doom-load-theme-hook #'efs/sync-window-borders)
  ;; reload gaps colors after a new frame is created
  (add-hook 'after-make-frame-functions (lambda (frame) (run-at-time "0.1 sec" nil #'efs/sync-window-borders frame)))
  ;;---------------------------
  :init
  (load-theme 'doom-one t))
#+end_src
* Modeline
** all-the-icons
https://github.com/domtronn/all-the-icons.el
*** Install icon fonts on OS (ArchLinux).
#+begin_src sh
paru -S ttf-all-the-icons
#+end_src
*** Install icon fonts on Emacs.
#+begin_src emacs-lisp
(use-package all-the-icons)
#+end_src
** doom-modeline
https://github.com/seagle0128/doom-modeline
#+begin_src emacs-lisp
(use-package doom-modeline
  :init (doom-modeline-mode 1)                    ;; enable modeline
  :custom ((doom-modeline-height 15)))            ;; adjust modeline height
#+end_src
* Org
#+begin_src emacs-lisp
(use-package org
  :custom
  (org-ellipsis " ▾")                   ;; set icon when section is folded (outline-hide-body)
  (org-edit-src-content-indentation 0)  ;; set indentation of source code block to zero
  (org-src-preserve-indentation t)      ;; preserve intentation on export
  :config
  ;; prettify checkboxes
  ;; source: https://jft.home.blog/2019/07/17/use-unicode-symbol-to-display-org-mode-checkboxes/
  (add-hook 'org-mode-hook (lambda ()
    "Beautify Org Checkbox Symbol"
    (push '("[ ]" . "☐") prettify-symbols-alist)
    (push '("[X]" . "☑") prettify-symbols-alist)
    (push '("[-]" . "❍") prettify-symbols-alist)
    (prettify-symbols-mode)))
  ;; unmap <RET> in 'evil-maps in order to =org-return-follows-link= to work
  (with-eval-after-load 'evil-maps
    (define-key evil-motion-state-map (kbd "RET") nil))
  ;; use <RET> to follow links in Org/Evil
  (setq org-return-follows-link  t)

  ;; remap header navigations
  (evil-collection-define-key 'normal 'org-mode-map
    ;; custom navigation: M-*
    (kbd "M-n") 'outline-promote   ;; promote header
    (kbd "M-e") 'outline-show-all  ;; show all
    (kbd "M-i") 'outline-hide-body ;; hide body
    (kbd "M-o") 'outline-demote    ;; demote header

    ;; custom navigation: C-*
    (kbd "C-n") 'outline-up-heading        ;; go to parent header
    (kbd "C-e") 'outline-next-heading      ;; goto next header
    (kbd "C-i") 'outline-previous-heading  ;; goto previous header

    ;; custom navigation: S-*
    (kbd "S-e") 'org-move-subtree-down  ;; goto next header
    (kbd "S-i") 'org-move-subtree-up    ;; goto previous header

    ;; custom navigation: S-C-*
    (kbd "S-C-e") 'org-forward-heading-same-level   ;; next same level 
    (kbd "S-C-i") 'org-backward-heading-same-level  ;; previous same level
  )
)
#+end_src
** Syntax highlighting
Make sure source code blocks get the right colors even if the header is off-screen.
#+begin_src emacs-lisp
;; syntax highlighting even if the header is off-screen
(setq jit-lock-contextually t)
;; increase the size of the chunk Emacs refontifies
(setq jit-lock-chunk-size 40000)
#+end_src
** org-bullets
Bullets as UTF-8 characters for headers in Org Mode.
https://github.com/sabof/org-bullets
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'org-indent-mode)
(use-package org-bullets)
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+end_src
** org-babel
#+begin_src emacs-lisp
(use-package ob
  :ensure nil  ;; do not install (org-babel is already built-in)
  :no-require  ;; do not load package (just add the config to the eval-after-load hook)
  :after org
  :custom
  (org-confirm-babel-evaluate nil)  ;; evaluate code blocks without confirmation
  :config
  (org-babel-do-load-languages
    'org-babel-load-languages
      '((python . t))))
#+end_src
** org-auto-tangle
Automatically tangle org files on save.
https://github.com/yilkalargaw/org-auto-tangle
#+begin_src emacs-lisp
(use-package org-auto-tangle
  :defer t
  :after ob
  :hook (org-mode . org-auto-tangle-mode)
  :custom
  (org-auto-tangle-default t)
  (org-auto-tangle-babel-safelist '(
     "/home/rafael/git/dotfiles/archlinux/archinstall/archinstall.org"
     "/home/rafael/git/dotfiles/brave/extensions.org"
     "/home/rafael/git/dotfiles/i3-sway/config.org"
     "/home/rafael/git/dotfiles/scripts/sway-dispatch.org"
     "/home/rafael/git/keebab/xremap/config.org"))
  :config
#+end_src
*** Autoformat
**** Header
#+begin_src emacs-lisp
(with-eval-after-load 'ob-tangle
  (add-hook 'org-babel-post-tangle-hook
    (lambda ()
#+end_src
**** JSON
#+begin_src emacs-lisp
(dolist (file (directory-files "." t "\\.json$"))
   (when (< (float-time (time-subtract (current-time) (file-attribute-modification-time (file-attributes file)))) 2.0)
     (message "Pretty printing %s..." file)
     (with-current-buffer (find-file-noselect file)
       (json-pretty-print-buffer)
       (save-buffer)
       (kill-buffer))))
#+end_src
**** shell script
#+begin_src emacs-lisp
(dolist (file (directory-files "." t "\\.sh$"))
  (when (< (float-time (time-subtract (current-time) (file-attribute-modification-time (file-attributes file)))) 2.0)
    (message "Formatting %s..." file)
    (with-current-buffer (find-file-noselect file)
      ;; "shell-command-on-region" is required to run shfmt synchronously
      ;; "-i 4" sets indentation to 4 spaces
      ;; "nil t" replaces the buffer content with the output
      (shell-command-on-region (point-min) (point-max) "shfmt -i 4" nil t)
      (save-buffer)
      (kill-buffer))))
#+end_src
**** EoS
#+begin_src emacs-lisp
)))
#+end_src
*** Auto-placement & Auto-reload
This is a custom config to copy some tangled files into predefined paths.
**** Header
#+begin_src emacs-lisp
(add-hook 'org-babel-post-tangle-hook
  (lambda ()
#+end_src
**** List of pairs
#+begin_src emacs-lisp
(let ((transfer-list `(
  ;; dotfiles
  (,(expand-file-name "~/git/dotfiles/i3-sway/config.org") . (("_config_sway"  . "~/.config/sway/_config")
                                                              ("_config_i3"    . "~/.config/i3/_config")))
  (,(expand-file-name "~/git/dotfiles/waybar/config.org")  . (("config"        . "~/.config/waybar/config")))
  (,(expand-file-name "~/git/dotfiles/waybar/style.org")   . (("style.css"     . "~/.config/waybar/style.css")))

  ;; keebab
  (,(expand-file-name "~/git/keebab/kanata/kanata.org")         . (("kanata.kbd"       . "~/.config/kanata/kanata.kbd")))
  (,(expand-file-name "~/git/keebab/scripts/sway-dispatch.org") . (("sway-dispatch.sh" . "~/.config/scripts/sway-dispatch.sh")))
  (,(expand-file-name "~/git/keebab/xremap/config.org")         . (("config_sway.yml"  . "~/.config/xremap/config.yml")))
)))
#+end_src
**** Match tangled file
Compare tangled file with the list predefined above.
#+begin_src emacs-lisp
;; the hook runs in the tangled file's buffer.
;; iterate through the previous list to see if the current buffer matches any defined output.
(dolist (entry transfer-list)
  (let ((org-file-path (car entry))
        (mappings (cdr entry)))

    (dolist (map-pair mappings)
      (let* ((tangled-file-name (car map-pair))
             (target-dest (expand-file-name (cdr map-pair)))
             ;; calculate the full path where the tangle file should be
             (expected-tangled-path (expand-file-name tangled-file-name (file-name-directory org-file-path))))

        ;; check if the current buffer is the file we just calculated
        (when (and (buffer-file-name)
                   (string= (expand-file-name (buffer-file-name)) expected-tangled-path))
#+end_src
**** Auto-placement
Copy tangled file to target.
#+begin_src emacs-lisp
(make-directory (file-name-directory target-dest) t)
(copy-file (buffer-file-name) target-dest t)
(message "✔ Deployed: %s" target-dest)
#+end_src
**** Auto-reload
Restart applications with new config file.
***** Header
#+begin_src emacs-lisp
(cond
#+end_src
***** kanata
#+begin_src emacs-lisp
((string-match-p "kanata" target-dest)
 (call-process-shell-command "systemctl --user restart kanata" nil "*Messages*")
 (message "↻ Restarting kanata..."))
#+end_src
***** Sway
#+begin_src emacs-lisp
;; generate "config" from "_config" using i3bang.rb, and then reload Sway
((string-match-p "sway" target-dest)
 (let* ((sway-dir (file-name-directory target-dest))
        (script-path (expand-file-name "i3bang.rb" sway-dir))
        (config-source (expand-file-name "_config" sway-dir))
        ;; find the active SWAYSOCK dynamically; run Ruby i3bang.rb script; reload Sway
        (cmd (format "export SWAYSOCK=$(ls /run/user/$(id -u)/sway-ipc.*.sock | head -n 1); ruby '%s' '%s' && swaymsg reload"
                     script-path
                     config-source)))
   ;; run synchronously to ensure it finishes before the hook exits
   (call-process-shell-command cmd nil "*Messages*")
   (message "↻ Generated & Reloaded Sway.")))
#+end_src
***** xremap
#+begin_src emacs-lisp
((string-match-p "xremap" target-dest)
 (start-process-shell-command "reload-xremap" "*Messages*" "systemctl --user restart xremap")
 (message "↻ Restarting xremap..."))
#+end_src
***** Waybar
#+begin_src emacs-lisp
((string-match-p "waybar" target-dest)
 (call-process-shell-command "pkill waybar; ~/.config/waybar/waybar.sh &" nil "*Messages*")
 (message "↻ Restarting Waybar..."))
#+end_src
***** EoS
#+begin_src emacs-lisp
)
#+end_src
**** EoS
#+begin_src emacs-lisp
)))))))))
#+end_src
** org-contrib
https://orgmode.org/worg/org-contrib/
#+begin_src emacs-lisp
(use-package org-contrib
  :config
  (require 'ox-extra)
  (ox-extras-activate '(ignore-headlines))
  :custom
  (org-export-allow-bind-keywords t))
#+end_src
** org-appear
https://github.com/awth13/org-appear
Toggle visibility of hidden Org mode element parts upon entering and leaving an element.
#+begin_src emacs-lisp
(use-package org-appear
  :after org
  :hook org-mode)
#+end_src
* Dired
** Dired
#+begin_src emacs-lisp
(use-package dired
  :ensure nil  ;; do not install (Dired is already built-in)
  :custom
  (dired-listing-switches "-agho --group-directories-first")  ;; list directories first
  (dired-kill-when-opening-new-dired-buffer t)                ;; keep only one Dired buffer when moving dir
  (dired-dwim-target t)                                       ;; set another Dired buffer as destination for operations
  :after evil-collection
  :config
  ;; make sure evil-collection is already loaded before trying to redefine the next keybindings
  (evil-collection-define-key 'normal 'dired-mode-map
    "n" 'dired-up-directory
    "e" 'dired-next-line
    "i" 'dired-previous-line
    "o" 'dired-find-file))

  ;;exit isearch and, if in dired-mode, visit the file or directory at point.
  (defun efs/dired-isearch-tab2visit ()
    (interactive)
    (when (derived-mode-p 'dired-mode)
      ;; defer the dired-find-file call slightly to run after isearch has exited
      (run-at-time 0 nil
        (lambda ()
          (when (derived-mode-p 'dired-mode)
            (dired-find-file)))))
    (isearch-exit))
  (define-key isearch-mode-map (kbd "TAB") #'efs/dired-isearch-tab2visit)
#+end_src
** all-the-icons-dired
https://github.com/jtbm37/all-the-icons-dired
#+begin_src emacs-lisp
(use-package all-the-icons-dired
  :hook (dired-mode . (lambda () (all-the-icons-dired-mode t)))
  :config
  (setq all-the-icons-dired-monochrome nil))
#+end_src
* General
Keybindings
https://github.com/noctuid/general.el
** Leader key
#+begin_src emacs-lisp
(use-package general
  :config
  (general-evil-setup)

  ;; set 'SPC' as the global leader key
  (general-create-definer efs/leader-keys
    :states '(normal insert visual emacs)
    :keymaps 'override
    :prefix "SPC"             ;; set leader
    :global-prefix "M-SPC")   ;; access leader in insert mode
#+end_src
** Misc
#+begin_src emacs-lisp
  (efs/leader-keys
    "SPC" '(counsel-M-x   :wk "Counsel M-x")
    "."   '(find-file     :wk "Find file")
    "TAB" '(comment-line  :wk "Comment lines")
    "x"   '(lambda () (interactive) (switch-to-buffer "*scratch*")  :wk "Goto scratch buffer")
  )
#+end_src
** b --> buffer
#+begin_src emacs-lisp
  (efs/leader-keys
    "b"   '(:ignore t :wk "buffer")
    "b k" '(kill-current-buffer      :wk "Kill this buffer")
    "b b" '(counsel-switch-buffer  :wk "Switch buffer")
    "b m" '((lambda () (interactive) (view-echo-area-messages) (other-window 1))  :wk "Open *Messages* buffer")
    "b n" '(next-buffer            :wk "Next buffer")
    "b p" '(previous-buffer        :wk "Previous buffer")
    "b r" '(revert-buffer          :wk "Reload buffer")
  )
#+end_src
** e --> eval
#+begin_src emacs-lisp
  (efs/leader-keys
    "e" '(:ignore t :wk "Evaluate")
    "e b" '(eval-buffer     :wk "Evaluate elisp in buffer")
    "e d" '(eval-defun      :wk "Evaluate defun containing or after point")
    "e e" '(eval-expression :wk "Evaluate and elisp expression")
    "e l" '(eval-last-sexp  :wk "Evaluate elisp expression before point")
    "e r" '(eval-region     :wk "Evaluate elisp in region")
  )
#+end_src
** f --> files
#+begin_src emacs-lisp
  (efs/leader-keys
    "f"  '(:ignore t :wk "Files")
    "f c" '((lambda () (interactive) (find-file "~/git/dotfiles/emacs/config.org")) :wk "Open emacs config.org")
    "f e" '((lambda () (interactive) (find-file "~/git/dotfiles/emacs/config.org")) :wk "Open emacs config.org")
    "f i" '((lambda () (interactive) (find-file "~/git/dotfiles/emacs/init.el"))    :wk "Open emacs init.el")
    "f r" '(counsel-recentf :wk "Find recent files")
    "f x" '((lambda () (interactive) (find-file "~/git/keebab/xremap/config.org"))    :wk "Open xremap dotfile")
    "f z" '((lambda () (interactive) (find-file "~/git/dotfiles/zsh/zshrc"))          :wk "Open zshrc dotfile")
  )
#+end_src
** g --> git
#+begin_src emacs-lisp
  (efs/leader-keys
    "g" '(:ignore t :wk "Git")
    "g g" '(magit-status           :wk "Magit status")
  )
#+end_src
** h --> help
#+begin_src emacs-lisp
  (efs/leader-keys
    "h" '(:ignore t :wk "Help")
    "h a" '(counsel-apropos   :wk "Apropos")
    "h b" '(describe-bindings :wk "Describe bindings")
    "h d" '((lambda () (interactive) (call-process (concat (getenv "XDG_CONFIG_HOME") "/scripts/emacs-respawn.sh") nil 0 nil) (restart-emacs)) :wk "Restart emacs daemon")
    "h f" '(describe-function :wk "Describe function")
    "h k" '(describe-key      :wk "Describe key")
    "h r" '((lambda () (interactive) (load-file "~/.config/emacs-efs/init.el") (ignore (elpaca-process-queues)))
            :wk "Reload emacs config")
    "h v" '(describe-variable :wk "Describe variable")
  )
#+end_src
** p --> project
#+begin_src emacs-lisp
  (efs/leader-keys
    "p" '(:ignore t :wk "Project")
    "p a" '(projectile-add-known-project :wk "Add new project")
    "p p" '(projectile-switch-project    :wk "Switch project")
    "p f" '(projectile-find-file         :wk "Find file in project")
  )
#+end_src
** r --> remote
#+begin_src emacs-lisp
  (efs/leader-keys
    "r" '(:ignore t :wk "Remote")
    "r c" '(tramp-cleanup-all-connections  :wk "Cleanup")
    "r l" '(lambda () (interactive) (find-file "/ssh:lbic:~"))
  )
#+end_src
** s --> search
#+begin_src emacs-lisp
  (efs/leader-keys
    "s" '(:ignore t :wk "Search")
    "s i" '(counsel-imenu :wk "Jump to symbol")
  )
#+end_src
** t --> toggle
#+begin_src emacs-lisp
  (efs/leader-keys
    "t" '(:ignore t :wk "Toggle")
    "t b" '(dashboard-open            :wk "Toggle dashboard")
    "t d" '(efs/dimmer-toggle         :wk "Toggle Dimmer")
    "t k" '(keycast-mode              :wk "Toggle keycast")
  )
#+end_src
** w --> window
#+begin_src emacs-lisp
  (efs/leader-keys
    "w" '(:ignore t :wk "Windows")
    ;; splits
    "w h" '(lambda () (interactive) (evil-window-split) (other-window 1)  :wk "Horizontal split window")
    "w s" '(lambda () (interactive) (evil-window-split) (other-window 1)  :wk "Horizontal split window")
    "w v" '(lambda () (interactive) (evil-window-vsplit) (other-window 1) :wk "Vertical split window")
    ;; kill
    "w q" '(evil-window-delete :wk "Close window")
    "w k" '(evil-window-delete :wk "Close window")
    ;; navigation --> keys
    "w n" '(evil-window-left   :wk "Window left")
    "w e" '(evil-window-down   :wk "Window down")
    "w i" '(evil-window-up     :wk "Window up")
    "w o" '(evil-window-right  :wk "Window right")
    "w w" '(evil-window-next   :wk "Goto next window")
    ;; navigation --> arrows
    "w <left>"  '(evil-window-left  :wk "Window left")
    "w <down>"  '(evil-window-down  :wk "Window down")
    "w <up>"    '(evil-window-up    :wk "Window up")
    "w <right>" '(evil-window-right :wk "Window right")
  )
#+end_src
** EoS
#+begin_src emacs-lisp
)
#+end_src
* orderless
#+begin_src emacs-lisp
(use-package orderless
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src
* Ivy
Alternatives:
  - [[https://github.com/emacs-helm/helm][Helm]]
** Ivy
Generic completion mechanism for Emacs.
https://github.com/abo-abo/swiper
#+begin_src emacs-lisp
(use-package ivy
  :diminish
  :bind (
       :map ivy-minibuffer-map
       ;("C-n"   . counsel-up-directory)     ;; left
       ("C-e"   . ivy-next-line)            ;; down
       ("C-i"   . ivy-previous-line)        ;; up
       ("C-o"   . ivy-alt-done)             ;; confirm
       ("<tab>" . ivy-alt-done)             ;; confirm
       :map ivy-switch-buffer-map
       ("C-e"   . ivy-next-line)            ;; down
       ("C-i"   . ivy-previous-line)        ;; up
       ("C-o"   . ivy-done)                 ;; confirm
       ("C-d"   . ivy-switch-buffer-kill)   ;; kill buffer
  )
  :config
  ;; integration with orderless
  (setq ivy-re-builders-alist '((t . orderless-ivy-re-builder)))
  (add-to-list 'ivy-highlight-functions-alist '(orderless-ivy-re-builder . orderless-ivy-highlight))

  ;; enable counsel-imenu preview
  (ivy-configure 'counsel-imenu
    :update-fn 'auto)

  ;; enable Ivy
  (ivy-mode 1))
#+end_src
** Ivy-rich
Add descriptions and keybindings to M-x commands.
*** ivy-rich
https://github.com/Yevgnen/ivy-rich
#+begin_src emacs-lisp
(use-package ivy-rich
  :after (ivy counsel)
  :init
  (ivy-rich-mode 1))
#+end_src
*** all-the-icons-ivy-rich
https://github.com/seagle0128/all-the-icons-ivy-rich
#+begin_src emacs-lisp
(use-package all-the-icons-ivy-rich
  :after ivy-rich
  :init (all-the-icons-ivy-rich-mode 1))
#+end_src
** Swiper
Ivy-enhanced alternative to Isearch.
#+begin_src emacs-lisp
(use-package swiper)
#+end_src
** Counsel
Collection of Ivy-enhanced versions of common Emacs commands.
#+begin_src emacs-lisp
(use-package counsel
  :after ivy
  :diminish
  :config
  (counsel-mode 1)
    (setq ivy-initial-inputs-alist nil))  ;; removes starting ^ regex in M-x
#+end_src
** prescient
Sorting and filtering extension for Ivy.
https://github.com/radian-software/prescient.el
#+begin_src emacs-lisp
(use-package ivy-prescient
  :after counsel
  :custom
  (ivy-prescient-enable-filtering nil)
  :config
  (setq prescient-sort-length-enable nil)  ;; disable sorting by shortest-first
  (prescient-persist-mode 1)  ;; keep sorting remembered across sessions
  (ivy-prescient-mode 1))
#+end_src
* rainbow-delimiters
https://github.com/Fanael/rainbow-delimiters
Add rainbow coloring to parentheses in every programming language mode.
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
* helpful
Helpful is an alternative to the built-in Emacs help that provides much more contextual information.
https://github.com/Wilfred/helpful
#+begin_src emacs-lisp
(use-package helpful
  :commands (helpful-callable helpful-variable helpful-command helpful-key)
  :custom
  (counsel-describe-function-function #'helpful-callable)  ;; replace describe-function function with helpful variant
  (counsel-describe-variable-function #'helpful-variable)  ;; replace describe-variable function with helpful variant
  :bind
  ([remap describe-function] . counsel-describe-function)  ;; remap keybinding of describe-function to counsel-describe-function
  ([remap describe-command]  . helpful-command)            ;; remap keybinding of describe-command to helpful-command
  ([remap describe-variable] . counsel-describe-variable)  ;; remap keybinding of describe-variable to counsel-describe-variable
  ([remap describe-key]      . helpful-key)                ;; remap keybinding of describe-key to helpful-key
)
#+end_src
* which-key
https://github.com/justbur/emacs-which-key
#+begin_src emacs-lisp
(use-package which-key
  :init
  (which-key-mode 1)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 0.25
        which-key-separator " → "
  )
)
#+end_src
* Hydra
https://github.com/abo-abo/hydra
** Installation
#+begin_src emacs-lisp
(use-package hydra
  :defer t
  :config
#+end_src
** Adjust font size
Define transient keybindings for changing the font size.
#+begin_src emacs-lisp
  (defhydra hydra-text-scale (:timeout 3)
    "Zoom text"
    ("i" text-scale-increase "out")
    ("e" text-scale-decrease "in"))

  (efs/leader-keys
    "t s" '(hydra-text-scale/body :which-key "scale text"))
#+end_src
** EoS
#+begin_src emacs-lisp
)
#+end_src
* Projectile
https://github.com/bbatsov/projectile
#+begin_src emacs-lisp
(use-package projectile
  :config (projectile-mode)
  :init
  ;; set directory that holds the Git repos
  (when (file-directory-p "~/git")
    (setq projectile-project-search-path '("~/git")))
  (setq projectile-switch-project-action #'projectile-dired))  ;; open dired when switching projects
#+end_src
** Counsel
Integration with Ivy/Counsel.
#+begin_src emacs-lisp
(use-package counsel-projectile
  :after (counsel projectile)
  :config (counsel-projectile-mode))
#+end_src
* Magit
** Transient
Transient is the library used to implement the keyboard-driven “menus” in Magit.
https://github.com/magit/transient
#+begin_src emacs-lisp
(use-package transient)
#+end_src
** Magit
https://github.com/magit/magit
It's Magit! A Git Porcelain inside Emacs.
#+begin_src emacs-lisp
(use-package magit
  :after transient
  :commands magit-status
  :custom
  (magit-section-disable-line-numbers nil)
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)  ;; show diff in the same window
  (magit-section-initial-visibility-alist
    '((stashes . hide)      ;; hide stashes
      (untracked . show)))  ;; show untracked
  :config
  (evil-set-initial-state 'git-commit-mode 'insert)  ;; start git-commit-mode in insert mode
  (evil-collection-define-key '(normal visual) 'magit-status-mode-map
    ;; override keybindings for =magit-section-show-level-{1,2,3,4}= and use as counts for evil commands
    "1" 'digit-argument
    "2" 'digit-argument
    "3" 'digit-argument
    "4" 'digit-argument
    ;; custom navigation
    (kbd "M-i") 'magit-section-show-level-2-all  ;; fold everything
  )
  ;;---------------------------
  ;; return to magit-status after a commit
  (add-hook 'git-commit-post-finish-hook 'magit)
  ;;---------------------------
  ;; return to magit-status after C-c C-k (with-editor-cancel)
  (defun my/magit-restore-status-smooth (orig-fun &rest args)
    "Cancel commit without flashing dashboard, then restore layout.
     Uses inhibit-redisplay to prevent the intermediate 'dashboard' state."
    (let* ((repo (magit-toplevel))
      ;; find the existing status buffer for this repo (if any)
      (status-buf (and repo (cl-find-if (lambda (b) (with-current-buffer b (and (derived-mode-p 'magit-status-mode) (equal (magit-toplevel) repo)))) (buffer-list)))))
      ;; freeze the display
      (let ((inhibit-redisplay t))
        ;; run the original cancel command (kills the commit buffer)
        (apply orig-fun args)
        ;; instantly swap to status buffer "in the dark"
        (when (and status-buf (buffer-live-p status-buf)) (switch-to-buffer status-buf)
          ;; force single window (closes diff/staged changes window)
          (delete-other-windows)))
      ;; run full refresh to fix transient prefixes after a small delay
      (when repo (run-at-time 0.05 nil (lambda (dir) (magit-status dir)) repo))))
  (advice-add 'with-editor-cancel :around #'my/magit-restore-status-smooth)
  ;;---------------------------
)
#+end_src
** Forge
Pulls down all information from repositories: issues, pull requests, notifications, etc.
https://magit.vc/manual/ghub/Getting-Started.html
*** Prerequisites
**** Setting the Username
https://magit.vc/manual/ghub/Setting-the-Username.html
***** GitHub
#+begin_src sh
git config --global github.user USERNAME
#+end_src
***** GitLab
#+begin_src sh
git config --global gitlab.user USERNAME
#+end_src
***** GitHub Enterprise
#+begin_src sh
cd /path/to/repo
git config --local github.host example.com/api/v3
#+end_src
**** Creating a Token
https://magit.vc/manual/forge/Token-Creation.html
https://magit.vc/manual/ghub/Creating-a-Token.html
***** GitHub
https://github.com/settings/tokens
Forge requires the following token scopes:
- =repo= grants full read/write access to private and public repositories.
- =user= grants access to profile information.
- =read:org= grants read-only access to organization membership.
***** GitLab
https://gitlab.com/-/profile/personal_access_tokens
For Gitlab instances =api= is the only required scope. It gives read and write access to everything.
**** Storing a Token
https://magit.vc/manual/ghub/Storing-a-Token.html
***** Create file
=M-x= --> =find-file= --> select the file =~/.config/authinfo= --> then paste the following:
****** GitHub
#+begin_src conf
machine api.github.com login ito-rafael^forge password <PERSONAL-ACCESS-TOKEN>
#+end_src
****** GitLab
#+begin_src conf
machine gitlab.com/api/v4 login ito-rafael^forge password <PERSONAL-ACCESS-TOKEN>
#+end_src
***** Encrypt file
- =M-x= --> =epa-encrypt-file= --> select the file =~/.config/authinfo= --> mark your personal keys with =epa-mark-key= --> hit =Enter= while the cursor is over the =[OK].=
- A new file =~/.config/authinfo.gpg= should have been created. Try opening it, while checking for a "Decrypting" message in the minibuffer.
***** Delete unencrypted file
=M-x= --> =find-file= --> select =~/.config/authinfo= --> press =M-o= --> =delete=
*** Installation & configuration
#+begin_src emacs-lisp
(use-package forge
  :after magit
  :config
  ;; define path for the authinfo file (XDG_CONFIG_HOME or HOME, whichever it finds first)
  (setq auth-sources (list
                     (concat (getenv "XDG_CONFIG_HOME") "/authinfo.gpg")
                     "~/.authinfo.gpg")))
#+end_src
* undo-tree
Alternatives:
  - undo-redo
  - undo-fu
  - vundo: https://github.com/casouri/vundo
#+begin_src emacs-lisp
(use-package undo-tree
  :config
  (global-undo-tree-mode 1))
#+end_src
* Dashboard
https://github.com/emacs-dashboard/emacs-dashboard
#+begin_src emacs-lisp
(use-package dashboard
  :init
  (setq initial-buffer-choice 'dashboard-open) ;; show Dashboard with emacsclient
  (setq dashboard-center-content t)              ;; center horizontally
  (setq dashboard-vertically-center-content t)   ;; center vertically
  (setq dashboard-startup-banner 'logo)  ;; use modern emacs logo as banner

  ;; number of items per widget
  (setq dashboard-items '(
    (recents   . 10)
    (agenda    . 5)
    (bookmarks . 3)
    (projects  . 5)
    ;(registers . 3)
  ))
  :config
  ;(add-hook 'dashboard-after-initialize-hook #'dashboard-jump-to-recents)  ;; start dashboard in recents section
  ;; start dashboard in recents section
  (defun efs/dashboard-refresh-on-frame ()
    (dashboard-refresh-buffer)    ;; fix icons & spacing
    (dashboard-jump-to-recents))  ;; start in recents section
  (add-hook 'server-after-make-frame-hook #'efs/dashboard-refresh-on-frame)
  ;; keybindings
  (evil-collection-define-key '(normal visual) 'dashboard-mode-map
    ;; custom navigation
    (kbd "o")   'dashboard-return            ;; enter file/dir
    (kbd "C-e") 'dashboard-next-section      ;; next section
    (kbd "C-i") 'dashboard-previous-section  ;; previous section
  )

  ;; always disable line numbers
  (when (get-buffer dashboard-buffer-name)
    (with-current-buffer dashboard-buffer-name
      (efs/disable-line-numbers)))
)
#+end_src
  :config
  (add-hook 'elpaca-after-init-hook #'dashboard-insert-startupify-lists)
  (add-hook 'elpaca-after-init-hook #'dashboard-initialize)
  (add-hook 'dashboard-after-initialize-hook #'dashboard-jump-to-recents)  ;; start dashboard in recents section
  (dashboard-setup-startup-hook))
#+end_src
* Docker
** docker.el
https://github.com/Silex/docker.el
#+begin_src emacs-lisp
(use-package docker)
#+end_src
** dockerfile-mode
https://github.com/spotify/dockerfile-mode
#+begin_src emacs-lisp
(use-package dockerfile-mode
  :mode ("Dockerfile\\'" . dockerfile-mode))
#+end_src
#+end_src
* windmove
Override the =windmove-do-window-select= function that is called by =windmove-{left,up,right,down}= (which in turn are used by the wrapper functions =evil-window-{left,up,right,down}=) to focus other windows outside of Emacs when trying to cross the Emacs frame barrier.
Supported window managers:
  - Sway
  - i3wm
#+begin_src emacs-lisp
(use-package windmove
  :ensure nil  ;; do not install (windmove is already built-in)
  :after windmove
  :config
  ;; Selects the window that's hopefully at the location returned by
  ;; `windmove-find-other-window', or screams if there's no window there.
  (defun windmove-do-window-select (dir &optional arg window)
    "Move to the window at direction DIR as seen from WINDOW.
  DIR, ARG, and WINDOW are handled as by `windmove-find-other-window'.
  If no window is at direction DIR, an error is signaled.
  If `windmove-create-window' is a function, call that function with
  DIR, ARG and WINDOW.  If it is non-nil, try to create a new window
  in direction DIR instead."
    (let ((other-window (windmove-find-other-window dir arg window)))
      (when (and windmove-create-window
                 (or (null other-window)
                     (and (window-minibuffer-p other-window)
                          (not (minibuffer-window-active-p other-window)))))
        (setq other-window (if (functionp windmove-create-window)
                               (funcall windmove-create-window dir arg window)
                             (split-window window nil dir))))
      (cond ((null other-window)
         ;;====================================================================
         ;; the next line (warning message) is replaced by the shell command
         ;; that focus the window outside of Emacs based on the =dir= variable
             ;;(user-error "No window %s from selected window" dir))
         ;;--------------------------------------------------------------------
	     ;; identify environment
             (setq wm_cmd (pcase (getenv "XDG_SESSION_TYPE")
	                    ("x11"      "i3-msg")
	                    ("wayland"  "swaymsg")
	                    ("tty"      "tty")
			    (_          "nil")))
	     ;; focus adjacent window
             (shell-command (concat wm_cmd " focus " (format "%s" dir) " > /dev/null 2>&1") t t))
         ;;====================================================================
            ((and (window-minibuffer-p other-window)
                  (not (minibuffer-window-active-p other-window)))
         ;;====================================================================
         ;; the next line (warning message) is replaced by the shell command
         ;; that focus the window outside of Emacs based on the =dir= variable
             ;;(user-error "Minibuffer is inactive"))
         ;;--------------------------------------------------------------------
	     ;; identify environment
             (setq wm_cmd (pcase (getenv "XDG_SESSION_TYPE")
	                    ("x11"      "i3-msg")
	                    ("wayland"  "swaymsg")
	                    ("tty"      "tty")
			    (_          "nil")))
	     ;; focus adjacent window
             (shell-command (concat wm_cmd " focus " (format "%s" dir) " > /dev/null 2>&1") t t))
         ;;====================================================================
            ((eq other-window 'no-select))
            (t
             (select-window other-window))))))
#+end_src
* Ansible
** yaml-mode
https://github.com/yoshiki/yaml-mode
#+begin_src emacs-lisp
(use-package yaml-mode)
#+end_src
** jinja2-mode
https://github.com/paradoxxxzero/jinja2-mode
#+begin_src emacs-lisp
(use-package jinja2-mode)
#+end_src
* Keycast
https://github.com/tarsius/keycast
#+begin_src emacs-lisp
(use-package keycast
  :hook (after-init . keycast-mode)
  :after doom-modeline
  :config
  (define-minor-mode keycast-mode
    "Show current command and its key binding in the mode line (fix for use with doom-mode-line)."
    :global t
    (if keycast-mode
      ;; insert keycast in modeline
      (progn
        (add-hook 'pre-command-hook 'keycast--update t)
        (add-to-list 'global-mode-string '("" keycast-mode-line " ")))
      ;; remove keycast from modeline
      (progn
        (remove-hook 'pre-command-hook 'keycast--update)
        (setq global-mode-string (delete '("" keycast-mode-line " ") global-mode-string))))))
#+end_src
#+end_src
* zoom-window
#+begin_src emacs-lisp
(use-package zoom-window
  :custom
  (zoom-window-mode-line-color "green")
  :config
  (global-set-key (kbd "M-s-f") 'zoom-window-zoom))
  #+end_src
* persistent-scratch
https://github.com/Fanael/persistent-scratch
Preserve the scratch buffer across Emacs sessions.
#+begin_src emacs-lisp
(use-package persistent-scratch
  :config
  (persistent-scratch-autosave-mode t))
#+end_src
* systemd
https://github.com/holomorph/systemd-mode
#+begin_src emacs-lisp
(use-package systemd)
#+end_src
* desktop-save-mode
Save and restore Emacs sessions.
#+begin_src emacs-lisp
(use-package desktop
  :ensure nil  ;; do not install (desktop is already built-in)
  :init
  (desktop-save-mode 1))
* consult-gh
Alternatives:
  - https://github.com/sigma/gh.el
** Prerequisites
#+begin_src sh
sudo pacman -S github-cli
#+end_src
** consult-gh
#+begin_src emacs-lisp
(use-package consult-gh
  :after consult)
#+end_src
* dimmer
https://github.com/gonewest818/dimmer.el
#+begin_src emacs-lisp
(use-package dimmer
  :demand t
  :custom
  (dimmer-fraction 0.5)
  (dimmer-use-colorspace :rgb)
  (dimmer-adjustment-mode :foreground)
  ;;---------------------------
  ;;exclude these these buffers/modes from dimming
  (dimmer-exclusion-regexp-list
   '("^ \\*Minibuf-.*\\*"
     "^ \\*Echo.*\\*"
     "^ \\*which-key\\*"
     "^ \\*Help\\*"
     "*NeoTree*"
     "*Treemacs*"
     "*dired*"))
  ;;---------------------------
  :config
  ;; apply presets for standard popups
  ;;(dimmer-configure-company-box)
  ;;(dimmer-configure-gnus)
  ;;(dimmer-configure-helm)
  ;;(dimmer-configure-hydra)
  ;;(dimmer-configure-magit)
  ;;(dimmer-configure-org)
  ;;(dimmer-configure-posframe)
  ;(dimmer-configure-which-key)
  ;;---------------------------
  ;; bugfix: force face color for forge (prevent 'reset being returned to dimmer)
  (with-eval-after-load 'forge
    (set-face-attribute 'forge-topic-header-line nil
                        :foreground (face-attribute 'default :foreground)))
  ;;---------------------------
  ;; var to track the remapping (buffer-local)
  (defvar-local efs/dim-cookie nil)

  (defun efs/dim-window-setup (&rest _)
    (when dimmer-mode
      (walk-windows (lambda (w) (with-selected-window w
        (if (eq w (selected-window))
          ;; focused window --> remove dimming
          (when efs/dim-cookie
            (face-remap-remove-relative efs/dim-cookie)
            (setq efs/dim-cookie nil))
          ;; unfocused window --> dimming it
          (unless efs/dim-cookie
            (setq efs/dim-cookie (face-remap-add-relative 'default 'shadow))))))
      nil 'visible)))

  (add-hook 'window-selection-change-functions #'efs/dim-window-setup)
  ;;---------------------------
  ;; switch focus that forces refresh
  (defun efs/external-window-move (direction)
    "Move window focus and force a full font refresh."
    ;; switch focus
    (cond
     ((eq direction 'left)  (evil-window-left 1))
     ((eq direction 'right) (evil-window-right 1))
     ((eq direction 'up)    (evil-window-up 1))
     ((eq direction 'down)  (evil-window-down 1)))
    ;; run the dimmer logic manually
    (efs/dim-window-setup)
    ;; force the display engine to re-read the flushed fonts
    (force-mode-line-update t)
    (redisplay t))
  ;;---------------------------
  (defun efs/dimmer-toggle ()
    "Toggle dimmer-mode and cleanup any existing dimming effects."
    (interactive)
    (if dimmer-mode
      ;; if dimmer is enabled --> disable it
      (progn
        (dimmer-mode -1)
        ;; manually clear out cookies from all visible windows
        (walk-windows
         (lambda (w)
          (with-selected-window w
            (when (bound-and-true-p efs/dim-cookie)
              (face-remap-remove-relative efs/dim-cookie)
              (setq efs/dim-cookie nil))))
          nil 'visible)
        (message "Dimmer disabled"))
      ;; if dimmer is disabled --> enable it
      (progn
        (dimmer-mode 1)
        (efs/dim-window-setup)
        (message "Dimmer enabled"))))
  ;;---------------------------
  :init
  (dimmer-mode 1)
)
#+end_src
* wgrep
#+begin_src emacs-lisp
(use-package wgrep
  :config
  (setq wgrep-auto-save-buffer t)      ;; automatically save buffer when =wgrep-finish-edit=
  (setq wgrep-change-readonly-file t)  ;; apply changes regardless read-only flag on buffers
  (setq wgrep-enable-key "s"))         ;; set keybinding to switch to wgrep
#+end_src
